"""
Check the output files against expected files.
This is part of the testing suite.

It checks that the output files generated by the examples match the expected output files.
"""

import sys
import os
import json

import skimage.io
import numpy as np

__dirname__ = os.path.dirname(os.path.abspath(__file__))


def json_deep_comp(obj_1: object, obj_2: object) -> bool:
    """
    Deep comparison of two json objects.
    a json object is a python object typically issued from `json.load` or `json.loads`.

    Arguments:
        o1: First object to compare.
        o2: Second object to compare.

    Returns:
        True if the objects are deeply equal, False otherwise.
    """

    def json_reordered(obj: object) -> object:
        if isinstance(obj, dict):
            return sorted((k, json_reordered(v)) for k, v in obj.items())
        if isinstance(obj, list):
            return sorted(json_reordered(x) for x in obj)  # type: ignore
        else:
            return obj

    obj_1 = json_reordered(obj_1)
    obj_2 = json_reordered(obj_2)
    return obj_1 == obj_2


def verify_file_content(expected_path: str, output_path: str) -> bool:
    """
    Verifies that the content of the output file matches the expected file.

    Arguments:
        expected_path: Path to the expected output file.
        output_path: Path to the actual output file.

    Returns:
        True if the contents match, False otherwise.
    """

    # Read expected content
    with open(expected_path, "rb") as file_reader:
        expected_content = file_reader.read()

    # Read output content
    with open(output_path, "rb") as file_reader:
        output_content = file_reader.read()

    # Compare content based on file type
    file_ext = os.path.splitext(expected_path)[1].lower()
    if file_ext in [".png", ".jpg", ".jpeg"]:
        # Compare images files

        # Read images as np.ndarray using skimage
        expected_image: np.ndarray = skimage.io.imread(expected_path)
        output_image: np.ndarray = skimage.io.imread(output_path)

        # structural similarity index to compare images perceptually - score between -1.0 and 1.0
        score: float = skimage.metrics.structural_similarity(expected_image, output_image, channel_axis=-1)  # type: ignore

        # tolerance threshold - 1.0 is exact match
        # Make this number less than 1.0 to allow for minor differences due to compression, etc.
        tolerance_threshold = 0.99
        content_match = score >= tolerance_threshold
    elif file_ext in [".json"]:
        # Compare json files
        expected_json = json.loads(expected_content)
        output_json = json.loads(output_content)
        content_match = json_deep_comp(expected_json, output_json)
    else:
        # default method: byte by byte comparison
        content_match = expected_content == output_content

    return content_match


###############################################################################
# Main script logic
#


def main() -> None:
    expected_folder = f"{__dirname__}/../examples/expected/"
    output_folder = f"{__dirname__}/../examples/output/"

    # get all basename of files in output directory
    expected_basenames = [basename for basename in os.listdir(expected_folder)]
    # keep only .png and .json files
    expected_basenames = [basename for basename in expected_basenames if basename.endswith(".png") or basename.endswith(".json")]

    for basename_file in expected_basenames:
        expected_path = f"{expected_folder}{basename_file}"
        output_path = f"{output_folder}{basename_file}"

        # display the basename of the file without new line, and flush the output
        print(f"Checking {basename_file} ... ", end="", flush=True)

        # check if the file exists in the output folder
        if not os.path.exists(output_path):
            print("\033[91mFAILED\033[0m")  # Red "FAILED"
            print(f"File {basename_file} does not exist in output folder.")
            sys.exit(1)

        # verify the content of the file
        matching_content = verify_file_content(expected_path, output_path)

        # Display result
        if matching_content:
            print("\033[92mOK\033[0m")  # Green "OK"
        else:
            print("\033[91mFAILED\033[0m")  # Red "FAILED"
            print(f"File {basename_file} does not match expected output.")
            sys.exit(1)

    print(f"All {len(expected_basenames)} files matched successfully. \033[92mOK\033[0m")


if __name__ == "__main__":
    main()
